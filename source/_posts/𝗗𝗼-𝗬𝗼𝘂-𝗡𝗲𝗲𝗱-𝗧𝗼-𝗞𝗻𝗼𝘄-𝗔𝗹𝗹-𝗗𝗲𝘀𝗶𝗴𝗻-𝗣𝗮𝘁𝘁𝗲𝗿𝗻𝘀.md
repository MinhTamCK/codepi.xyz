---
title: ğ——ğ—¼ ğ—¬ğ—¼ğ˜‚ ğ—¡ğ—²ğ—²ğ—± ğ—§ğ—¼ ğ—ğ—»ğ—¼ğ˜„ ğ—”ğ—¹ğ—¹ ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€?
date: 2024-02-19
tags:
  - programming
image: https://pbs.twimg.com/media/GGeK_j6WoAMnrov?format=jpg&name=large
comments: false
---
ğ——ğ—¼ ğ—¬ğ—¼ğ˜‚ ğ—¡ğ—²ğ—²ğ—± ğ—§ğ—¼ ğ—ğ—»ğ—¼ğ˜„ ğ—”ğ—¹ğ—¹ ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€?

The answer is no. Even though we have 23 design patterns, around 10 are mostly used in everyday development. Knowing which patterns exist overall is good, but you need to know these very well.

Design patterns can be divided into three main types:

ğŸ­. ğ—–ğ—¿ğ—²ğ—®ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€

These design patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

Important patterns in this group are:

ğŸ”¹ğ—™ğ—®ğ—°ğ˜ğ—¼ğ—¿ğ˜†: This pattern allows delegating the instantiation logic to factory classes. The Factory Method creates objects without exposing the instantiation logic to the client.

ğŸ”¹ğ—¦ğ—¶ğ—»ğ—´ğ—¹ğ—²ğ˜ğ—¼ğ—»: The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. It's useful when exactly one object is needed to coordinate actions across the system.

ğŸ®. ğ—¦ğ˜ğ—¿ğ˜‚ğ—°ğ˜ğ˜‚ğ—¿ğ—®ğ—¹ ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€

These patterns deal with the composition of classes and objects that form larger structures.

Important patterns in this group are:

ğŸ”¹ğ—”ğ—±ğ—®ğ—½ğ˜ğ—²ğ—¿: This pattern works as a bridge between two incompatible interfaces. It wraps an existing class with a new interface to become compatible with the client's interface.

ğŸ”¹ğ—™ğ—®ğ—°ğ—®ğ—±ğ—²: The FaÃ§ade pattern provides a unified interface to a set of interfaces in a subsystem. FaÃ§ade defines a higher-level interface that makes the subsystem easier to use.

ğŸ”¹ğ——ğ—²ğ—°ğ—¼ğ—¿ğ—®ğ˜ğ—¼ğ—¿: This pattern dynamically adds/overrides behavior in an existing method of an object. This pattern provides a flexible alternative to subclassing for extending functionality.

ğŸ”¹ğ—£ğ—¿ğ—¼ğ˜…ğ˜†: The Proxy pattern provides a surrogate or placeholder for another object to control access to it. In its most general form, a proxy is a class functioning as an interface to something else.

ğŸ¯. ğ—•ğ—²ğ—µğ—®ğ˜ƒğ—¶ğ—¼ğ—¿ğ—®ğ—¹ ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€

These patterns are specifically concerned with communication between objects and how they interact and distribute work.

Important patterns in this group are:

ğŸ”¹ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±: The Command pattern encapsulates a request as an object, thus allowing users to parameterize clients with queues, requests, and operations.

ğŸ”¹ğ—§ğ—²ğ—ºğ—½ğ—¹ğ—®ğ˜ğ—² ğ— ğ—²ğ˜ğ—µğ—¼ğ—±: This pattern defines the program skeleton of an algorithm in a method called template method, which defers some steps to subclasses.

ğŸ”¹ğ—¦ğ˜ğ—¿ğ—®ğ˜ğ—²ğ—´ğ˜†: The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

ğŸ”¹ğ—¢ğ—¯ğ˜€ğ—²ğ—¿ğ˜ƒğ—²ğ—¿: This pattern defines a one-to-many dependency between objects so that all its dependents are notified and updated automatically when one object changes state.

sï»¿ource: @milan_milanovic